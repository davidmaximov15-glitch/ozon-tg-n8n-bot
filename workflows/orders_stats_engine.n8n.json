{
  "name": "orders_stats_engine",
  "nodes": [
    {
      "parameters": {
        "operation": "get",
        "propertyName": "value",
        "key": "=ozon:sess:{{ $json.user_id }}:csv"
      },
      "id": "redis_get_csv",
      "name": "Get CSV Session (records)",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "credentials": { "redis": { "id": "kaA0Glj8bB5pwqRt", "name": "Redis account" } },
      "position": [-680, 200]
    },
    {
      "parameters": {
        "jsCode": "// INPUT: { user_id, chat_id, selectedDates[], session }\n// CSV meta from Redis: { reportType, records, availableDates, totalRecords }\n// Specs: UTC -> MSK, cancellations include returns, revenue statuses list, avg price is weighted by quantity.\n// ‚Äî rules: ozon_bot_–ó–∞–∫–∞–∑—ã_spec.txt\n\nfunction parseUtcToMsk(dateStr){\n  // robust parse: new Date(dateStr + 'Z') may break if str already has TZ; try Date.parse, then treat as UTC\n  const t = Date.parse(dateStr);\n  if (Number.isFinite(t)) {\n    // input is UTC per spec; convert to MSK (UTC+3)\n    const d = new Date(t);\n    const msk = new Date(d.getTime() + 3*60*60*1000);\n    return msk;\n  }\n  return null;\n}\n\n// load meta\nlet meta={};\ntry{ const raw = $('Get CSV Session (records)').first().json.value; meta = raw? JSON.parse(raw) : {}; }catch(e){ meta={}; }\nconst records = Array.isArray(meta.records)? meta.records : [];\nconst selected = Array.isArray($json.selectedDates)? $json.selectedDates : [];\nconst selectedSet = new Set(selected);\n\n// statuses from spec\nconst STATUS_REVENUE = new Set(['–¥–æ—Å—Ç–∞–≤–ª–µ–Ω','–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è','–æ–∂–∏–¥–∞–µ—Ç —Å–±–æ—Ä–∫–∏','–æ–∂–∏–¥–∞–µ—Ç –æ—Ç–≥—Ä—É–∑–∫–∏']);\nconst STATUS_CANCELS = new Set(['–æ—Ç–º–µ–Ω—ë–Ω','–≤–æ–∑–≤—Ä–∞—Ç']);\n\n// filter by selected dates (MSK day)\nconst filtered = [];\nfor(const r of records){\n  const d = parseUtcToMsk(r.created_at);\n  if(!d) continue;\n  const day = d.toISOString().slice(0,10); // ISO (MSK) day\n  if(!selectedSet.has(day)) continue;\n  filtered.push({ sku: String(r.sku||'').trim(), quantity: Number(r.quantity||0), price: Number(r.price||0), status: String(r.status||'').toLowerCase(), date: day });\n}\n\n// aggregate per SKU\nconst bySku = new Map();\nfor(const row of filtered){\n  if(!row.sku) continue;\n  if(!bySku.has(row.sku)) bySku.set(row.sku, { totalOrders:0, cancellations:0, qtyForAvg:0, sumForAvg:0, totalRevenue:0 });\n  const agg = bySku.get(row.sku);\n  if(STATUS_REVENUE.has(row.status)){\n    agg.totalOrders += row.quantity;\n    agg.qtyForAvg   += row.quantity;\n    agg.sumForAvg   += row.price * row.quantity;\n    agg.totalRevenue+= row.price * row.quantity;\n  }\n  if(STATUS_CANCELS.has(row.status)){\n    agg.cancellations += row.quantity; // returns included\n  }\n}\n\n// finalize & overall totals\nconst skuStats = {};\nlet tOrders=0,tCanc=0,tRev=0;\nfor(const [sku, a] of bySku.entries()){\n  const avgPrice = a.qtyForAvg>0 ? a.sumForAvg/a.qtyForAvg : 0;\n  skuStats[sku] = { totalOrders:a.totalOrders, cancellations:a.cancellations, avgPrice, totalRevenue:a.totalRevenue };\n  tOrders += a.totalOrders; tCanc += a.cancellations; tRev += a.totalRevenue;\n}\n\nconst result = { date: selected, startTime: '00:00', endTime: '24:00', totalOrders:tOrders, totalCancellations:tCanc, totalRevenue:tRev, skuStats };\nreturn [{ json: { chat_id: $json.chat_id, stats: result } }];"
      },
      "id": "calc_stats",
      "name": "Calculate Stats",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-420, 200]
    },
    {
      "parameters": {
        "jsCode": "const s = $json.stats || {};\nfunction fmt(s){\n  let m = `üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–∫–∞–∑–æ–≤</b>\\n\\n`;\n  const dates = Array.isArray(s.date)? s.date.join(', ') : s.date;\n  m += `üìÖ –î–∞—Ç—ã: ${dates||'‚Äî'}\\n`;\n  m += `‚è∞ –í—Ä–µ–º—è: ${s.startTime||'00:00'} - ${s.endTime||'24:00'}\\n\\n`;\n  if((s.totalOrders||0)===0 && (s.totalCancellations||0)===0){\n    m += '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–º –¥–∞—Ç–∞–º';\n    return m;\n  }\n  const keys = Object.keys(s.skuStats||{}).sort();\n  for(const k of keys){\n    const x = s.skuStats[k];\n    m += `<b>${k}</b>\\n  ‚Ä¢ –ó–∞–∫–∞–∑–æ–≤: ${x.totalOrders}\\n  ‚Ä¢ –û—Ç–º–µ–Ω: ${x.cancellations}\\n  ‚Ä¢ –°—Ä–µ–¥–Ω—è—è —Ü–µ–Ω–∞: ${x.avgPrice.toFixed(2)} ‚ÇΩ\\n  ‚Ä¢ –°—É–º–º–∞: ${x.totalRevenue.toFixed(2)} ‚ÇΩ\\n\\n`;\n  }\n  m += `<b>–ò–¢–û–ì–û:</b>\\n  ‚Ä¢ –í—Å–µ–≥–æ –∑–∞–∫–∞–∑–æ–≤: ${s.totalOrders}\\n  ‚Ä¢ –í—Å–µ–≥–æ –æ—Ç–º–µ–Ω: ${s.totalCancellations}\\n  ‚Ä¢ –û–±—â–∞—è —Å—É–º–º–∞: ${s.totalRevenue.toFixed(2)} ‚ÇΩ`;\n  return m;\n}\nreturn [{ json: { chat_id: $json.chat_id, text: fmt(s), parse_mode: 'HTML' } }];"
      },
      "id": "format_message",
      "name": "Format Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-160, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.telegram.org/bot{{ $env.TELEGRAM_BOT_TOKEN }}/sendMessage",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { chat_id: $json.chat_id, text: $json.text, parse_mode: $json.parse_mode } }}",
        "options": {}
      },
      "id": "tg_send",
      "name": "Telegram sendMessage (stats)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [100, 200]
    }
  ],
  "connections": {
    "Get CSV Session (records)": { "main": [ [ { "node": "Calculate Stats", "type": "main", "index": 0 } ] ] },
    "Calculate Stats": { "main": [ [ { "node": "Format Message", "type": "main", "index": 0 } ] ] },
    "Format Message": { "main": [ [ { "node": "Telegram sendMessage (stats)", "type": "main", "index": 0 } ] ] }
  },
  "pinData": {},
  "active": false
}
